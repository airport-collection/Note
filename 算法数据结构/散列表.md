# 直接寻址表

这是一种理想化的状态，即对于一个集合U和一个数组T，U中一个元素都对应了T中的一个位置（槽）。

# 散列表

由于直接寻址表有一个致命的缺陷就是当U中最大的元素值很大时，就导致T所占空间也很大，很多时候分配这么大的空间是不可能的，而且如果元素值差异太大的话也会导致空间的浪费。所以就需要采用一种策略来避免分配大空间，这种策略叫做哈希函数。对于一个给定的元素x，通过计算hash(x)就可以得到元素x的位置。但这样会导致一个问题就是可能会有多个元素被映射到同一个位置上，即通过哈希函数计算后得到的结果一致。所以如何选择哈希函数就变得格外重要。

## 哈希函数（散列函数）

好的散列函数能够尽可能让元素在数组中均匀分配，也就是不会让大多数元素扎堆在同一个槽中。

### 除法散列法

通常取关键字k除以m的余数，这里的m指的是槽的个数。

$$h(k)\quad=\quad k \quad mod \quad m$$

这里m的取值就十分重要，直接决定散列表的性能。通常m的取值为一个不太接近2的整数幂的素数，为什么要选择素数，因为素数只能被1和其自身整除，所以得到的hash值比较均匀。

### 乘法散列法

取一个常数A（$0<A<1$）,然后取关键字k乘以A后的小数部分：

$$h(k) \quad = \quad \lfloor m(kA \quad \mod \quad 1) \rfloor$$

### 全域散列法

这种方法是解决散列函数被恶意针对，这种恶意针对常常选择一堆在某种哈希函数下值相同的元素，导致这些元素堆积在同一个槽中。这种方法的策略是随机地选择散列函数。



## 冲突解决

### 链接法

即每一个槽指向一个链表，用于保存哈希值重复的元素。对于n个元素，m个槽位，散列表T的装填因子为$\alpha = n/m$ 。

### 开放定址法

这种方法没有链表，所有的元素都存储在表内部。而且其装填因子$\alpha$绝对不会超过1，即表长度始终大于待装填元素的个数。当发生冲突时，此时需要进行探测，直到探测到一个空槽。至于如何进行探测，有以下几种方法：

#### 线性探测

这种方法在发生冲突的地方往后依次探测，如果到了末尾，然后继续回到表开始处继续探测。由于装填因子不会大于1，所以总会找到一个空位。这种方法很容易导致群集现象，随着连续被占用的槽增加，其探测的性能就会降低。

#### 平方探测

这种方法有不同的实现方式，基本原理都是在探测的时候以平方比例向外探测。

#### 双重散列







