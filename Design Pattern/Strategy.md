实现一个排序的工具，最简单的方法就是直接针对某一类对象进行排序。比如，需要对学生语文成绩排序，那么直接在排序代码中进行语文成绩的比较。但是这样有一个很大的问题，就是如果又要对教师进行教龄排序，那么又要写一个排序方法，这样下去，会造成大量的代码耦合。

在Java中，解决上述问题的手段可以让需要比较的对象都实现一个接口叫做java.lang.Comparable，只需定义一个排序方法，可以所有实现了该接口的对象进行排序。该接口定义了一个方法叫做CompareTo，具体的比较逻辑就写在这里面，这样就实现了一个方法复用的效果。

但是，CompareTo只能指定一种排序**策略**，为了实现另外一种策略，就只有把之前的代码删掉或注释掉，总之，可扩展性不是很高。

Java里面还有另外一个接口叫做java.util.Comparator，顾名思义，该接口允许为类定义一个比较器，该比较器中可以定义需要比较的策略，这种方法比Comparable的方法的区别在于，Comparable方式将策略与对象耦合了，而Comparator将其分离。举个例子，当需要对学生进行不同科目的成绩排序时，只需要传入不同的比较器即可，而不用反复修改CompareTo方法。

说句题外话，lambda表达式的流行，大大简便了策略模式的编码，至少在排序这个例子里面是这样的。



另外，还需思考在更多的场景下，该模式的运用。