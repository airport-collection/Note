

# 二位数组地址
```c
int a[2][3];
```
对于下列三个地址：
* a
* &a[0]
* &a[0][0]

虽然上述三者指向内存中的同一位置，但是在编译器看来却具有不同的含义，这里的含义具体来看就是所谓的步长。
第一个和第二个是等价的，因为其步长都是3, 但是第三个步长是1, 这就是关键的区别。
所以最好不要进行如下赋值：
```c
int a[2][3] = {1, 2, 3, 4, 5, 6};
int *p = a; // Warning
int *q = &a[0]; // Warning
```
上述p和q的赋值可能会导致[-Wincompatible-pointer-types]异常。a和&a[0]更像是一个数组指针，而不是一个整型指针。

# 数组指针
顾名思义，是一个指针，指向数组。
比如：
```c
int a[2][3] = {1, 2, 3, 4, 5, 6};
int (*p)[3] = a;

// 上诉定义可以理解为： int[3] (*p)， 其中int[3]为类型，(*p)为定义，意思就是指针p指向了一个int[3]类型的变量。
// 不能指向其他的类型，比如int[4]等。
```
这样就不会报[-Wincompatible-pointer-types]的异常。

# 指针数组
是一个数组，类型是指针，也就是说每一个元素都是指针类型的。
定义形式如下：
```c
int* p[3];
```
注意和数组指针对比，数组指针定义之所以要加括号，是因为符号优先级的问题。

# 字符数组与字符指针
注意分析内存四区，字符串字面量被保存在常量区中，对于下列代码：
```c
char a[] = "harrisonlee";
char *b = "harrisonlee";
a = "Mike Pence"; // Error
b = "Mike Pence"; // OK
strcpy(a, "Mike Pence");// OK
strcpy(b, "Mike Pence");// Error
```
对于第1行，首先字面量"harrisonlee"被保存到常量区，然后在堆中创建一块空间，将字面来拷贝到该空间，并返回该空间地址值给该数组名a。
然而，对于第二行，直接将常量区中的地址返回给b。
这也就是为什么对于那两行strcpy, 数组方式可行，而指针方式不可行，因为指针指向常量区中，而不能被写覆盖。而数组指向堆中，可以任意修改。
对于第三四句，数组名是常量，数组一旦在堆中创建空间后，就一直指向该空间，不能指向其他的空间。第三句其实是让栈上变量a指向了常量池。
第四句明显正常，无需多解释。


# 常量指针与指针常量
从左到右，先看到const再看到指针标志则叫做常量指针，反之，先看到指针标志在看到const则叫做指针常量。

常量指针
```c
const int *p;
int const *p;
```
指针常量
```c
int* const p;
```

指针常量是一个常量，类型是指针，也就是说指针一旦指向后就不能再改变指向。
常量指针，是一个指针，所指向的是一个常量，也就是说不能通过该指针来改变被指向的内存区域的值。
注意所指的常量是不能通过**当前**符号引用来修改值，但是可以通过**其他**符号引用指向该地址空间，从而间接修改值。

同时是常量指针，也是指针常量。
```c
const int* const p;
```
同时具备指针常量和常量指针的特性。

# 函数与指针

## 指针函数
 指针函数，是一个函数，只不过返回值类型是指针。
## 函数指针
函数指针，是一个指针，指向一个函数。
举一个例子来说明此概念：
```c
int add(int a, int b) 
{
    return a + b;
}

int main()
{
    int a = 3, b = 5;
    // 定义函数指针
    int (*p)(int, int); // 这里的参数类型列表必须和未来该函数指针所要指向的函数的参数类型列表一致。
    p = add;
    int ret = p(a, b);
    return 0;
}
```
### 函数指针数组
理解了函数指针，那么函数指针数组意思就是将多个函数指针放在一个函数里面，定义如下：
```c
int add(int a, int b) 
{
    return a + b;
}

int sub(int a, int b)
{
    return a - b;
}

int main()
{
    int a = 3, b = 5;

    // 定义函数指针数组
    int (*funcs[2])(int, int);
    funcs[0] = add;
    funcs[1] = sub;
    
    int sum = funcs[0](a, b);
    int sub = funcs[1](a, b);
    return 0;
}
```

## 补充
注意理解概念，比如： 
指向指针函数的函数指针
    首先，是一个指针，指向一个函数，而且这里的函数是指针函数，即返回值为指针的函数。

指向指针函数的函数指针数组
    首先，是一个数组，数组的类型是函数指针，即每一个元素是指针，指向一个函数，但是这里的函数是指针函数，即返回值为指针类型的函数。
    int* (*funcs[N])(int, int, ...)