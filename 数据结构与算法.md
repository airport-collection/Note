# 算法



常见的算法思想：枚举、递推、分治、贪心、回溯（试探）、迭代（碾转）、动态规划、模拟



## 排序

### 内排序

#### 插入类排序

##### 直接插入排序

请深刻理解“插入”二字的含义。对于基本有序的待排序序列比较友好，复杂度较低，但是相反，对于待排序结果逆序的序列，复杂度就较高了。

由于插入过程是从前向后，依次选择元素插入，所以之前位于较前的元素插入后还是位于前面，反之后面的元素后插入还是位于较后，当然在进行比较插入的时候，不能使用大于等于或小于等于，否则会破坏稳定性。

变种：

* 发现逆序对交换
* 查找待插入位置时，采用二分法，因为前面的序列已经是有序的（该优化后还是稳定的）

基本选择排序适合序列基本有序或者是序列本身较短小的情况。

##### 希尔排序

希尔排序就是基本选择排序的改进，在最后一轮的时候，序列已经基本有序了，所以在进行选择排序，效率就较高。

提高希尔排序的关键是要找到合适的步长，因为很有可能当前排序的子序列中有些数据在上一轮的排序中就已经比较过了，这也是导致shell排序效率低下的原因。

希尔排序虽然对直接插入排序进行了改进，但是不是稳定的，因为不同的步长比较，会让排序前相等元素打乱之前的相对顺序。

思考：

* shell排序中如何选择最高效的步长？
* 每一轮的子排序可以用其他方法吗？



#### 选择类排序

##### 直接选择排序

为什么不是稳定的，有没有什么办法修改为稳定的？

该排序有交换和插入两种实现方式，前者实现不是稳定的，后者实现可以是稳定的。

由于交换时，无法保证待排序序列中最小（或最大，下述同理）元素与被交换元素之间是否存在有与被交换元素相同的元素，所以会导致不稳定性。

对于数组，推荐使用交换法，对于链表推荐插入法。交换法不稳定，插入法则是稳定的。



##### 堆排序

排序过程中需要建立堆，有大根堆和小根堆之说，可否改进？发现逆序对立即交换。



#### 交换类排序

##### 冒泡排序



##### 快速排序 :six_pointed_star:

基于分治的思想，利用递归来实现。

轴值选择RQS，消除递归（用栈？队列？）



冒泡排序和直接选择排序哪个更优？为什么？

快速排序为什么不稳定？







### 外排序







# 数据结构

 ## 树

二叉树的遍历，前序遍历、中序遍历、后序遍历、层序遍历（递归+非递归），线索二叉树。

二叉搜索树（BST），平衡二叉树（AVL），哈夫曼树。

B树（B-）树，B+树，B*树，R树。

红黑树。



## 图

深度优先遍历、广度优先遍历。

最小生成树，Prime算法和Kruskal算法。

最短路径问题，单源最短路径、所有节点对的最短路径问题。

Dijkstra堆优化问题。

拓扑排序



## 优先队列



## 堆和二叉堆

