虚拟机字节码执行引擎

Java虚拟机以方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。
每一个栈帧都包括局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。
一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。

局部变量表：
	变量槽是最小单位


方法的调用：解析和分派
Java虚拟机支持以下5条方法调用字节码指令，分别是：
	invokestatic: 用于调用静态方法。
	invokespecial: 用于调用实例构造器。
	invokevirtual: 用于调用所有的虚方法。
	invokeinerface: 用于调用接口方法，会在运行时确定一个实现该接口的对象。
	invokedynamic: 现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用。

“重载”和“重写”在虚拟机层面是如何实现的？

“重载”和静态分派有关系：举个例子：
	List<String>list = new ArrayList<>();
	上面代码中的"List"是变量的”静态类型”或者叫“外观类型”，
	后面的"ArrayList"被称为变量的“实际类型”或者叫“运行时类型”。
	静态类型和实际类型在使用中都可能发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会发生改变，并且最终的静态类型是在编译期可知的；
	而实际类型的变化结果在运行期间才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。
	
“重写”和动态分派有关系

重载(Overload)是在一个类中，有多个名称相同的方法，这几个方法之所以共存，是因为每个方法有不同的参数列表（参数类型、顺序，注意与参数的名称无关），
	而与参数的返回值无关，可以相同也可以不相同, 不同重载方法抛出的异常之间没有依赖影响，方法能够在一个类中或子类中被重载。
	方法重载要求方法具有不同的特征签名，Java代码里面的方法特征签名只包括了方法名称、参数顺序及参数的类型。而在字节码中的特征签名还包括方法返回值及受检异常表。
	
重写(Override)是基于继承的，即子类重写父类的相同名称的方法，但是由一些要求：
	* 参数列表必须与被重写方法完全相同
	* 返回类型与被重写方法必须相同（JDK5及以前），但JDK7以后就不要求必须相同了，也可以是被重写方法返回类型的派生类型。
	* 重写方法的访问权限不能比被重写方法的访问权限更低。比如被重写方法为protected，那么重写方法不能是private的。
	* final方法不能被重写；被static修饰的方法不能被重写，但是可以声明，意思就是可以各自存在一个同名的方法。
	* 子类能够重写父类的方法的前提是子类有对父类方法的访问权限。
	* 构造方法不能被重写。
	* 关于异常，重写方法不能抛出任何比被重写方法所抛出的异常更广泛的异常；但重写方法能够抛出任何非强制性的异常。

很多时候在IDE中，会弹出要求给重写方法添加@Override注解的提示，其实这不是必须的。







