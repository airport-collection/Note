# 垃圾收集分类

## 部分收集

* 新生代收集（Minor GC/Young GC）
* 老年代收集（Major GC/Old GC）
* 混合收集（Mixed GC）

## 整堆收集

* 整堆收集（Full GC）



# 垃圾收集算法

## 标记-清除

标记-清除

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

缺点：

执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作。导致标记和清除两个过程的执行效率都随对象数量增长而降低。

内存空间碎片化，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

## 标记-复制

将内存按容量划分为大小相等的两块，每次只使用其中的一块。当其中一块内存空间用完了，就把还存活的对象复制到另一块。对于多数对象都是存活的情况，那么将会产生大量的内存复制的开销。但是如果大部分对象都是要销毁的话，那么这种方法就很合适。不过，空间浪费巨大，每次只能使用其大小的一半。

IBM曾经调查，新生代中的对象有98%熬不过第一轮收集。因此不需要按照1:1的比例来分配，每次分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，将还存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉之前的Eden和Survivor空间。`HotSpot`虚拟机默认Eden和Survivor的大小比例为8:1。每次新生代中可用内存空间为整个新生代容量的90%，只有一个Survivor空间即10%会被浪费。当时当剩下的10%空间不够存放存活对象时，就需要依赖其他内存区域（如老年代）进行分配担保。

对象在Survivor区中每熬过一次Minor GC，那么年龄就增加1岁，当增加到一定程度，默认为15，就会被晋身到老年代中,可以通过`-XX:MaxTunringThreshold`指定。

## 标记-整理

经过以上分析，标记-复制算法在存活对象较多时就要进行较多的复制操作，效率就会降低。另外空间浪费比较大，就算不使用1:1的比例，也需要空间担保。所以老年代一般不使用这种算法，而采用标记-整理。和标记-清除算法一样，先标记，但是后续步骤不是直接对可回收对象进行清理，而是让所有的存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存（解决了清除后内存碎片的问题）。