虚拟机类加载机制

七个阶段

加载
连接：
	验证
	准备
	解析
初始化
使用
卸载

解析阶段可能在初始化之前，也可能在其之后。

下面六个阶段，如果类没有初始化过，必须对类进行初始化：
1. 遇到new、getstatic、putstatic或invokestatic这四条指令时
	(1) 使用new关键字实例化对象
	(2) 读取或设置一个类型的静态字段
	(3) 调用一个类型的静态方法
2. 使用java.lang.reflect包的方法对类进行反射调用的时候
3. 初始化类时，父类如果没有初始化，则先初始化父类
4. 当虚拟机启动时，初始化主类
5. 【与动态语言相关，暂时不考虑】
6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的方法）时，如果这个接口的实现类实现了初始化，那么该接口要在其之前被初始化

上述六种场景中的行为称为对一个类型进行主动引用，除此之外，所有引用方式都不会触发初始化，称为被动引用。
	* 通过子类引用父类的静态字段，不会导致子类的初始化
	* 通过数组定义来引用类，不会触发此类的初始化
	* 常量在编译阶段会存入调用类的常量池中【常量传播优化】，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化


接口中不能使用static{}静态语句块，但是编译器仍然会为其生成<clinit>类构造器，用于初始化其中的属性。
接口与类初始化不同的地方在于上面六点中的第三点：当一个类初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，只有当真正用到其父类时才会初始化。

在准备阶段，为类中的静态变量分配内存并设置类变量的初始值，注意这里的初始值通常是指的对应数据类型的零值
所谓“通常”是因为如果存在final修饰的属性，在准备阶段就会将其值设置为给定的值。


解析阶段其实就是将常量池中的符号替换为直接引用的过程。直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
类或接口的解析 P274
字段解析 查找字段时，是从下往上找。如果有一个同名字段同时出现在某个类实现的接口和其父类当中，Javac可能直接拒绝编译。
		记住严格按照从下层到上层的关系，同一层的优先级相等，即父类或者实现的接口并没有先后顺序，如果出现了相同名称的字段，那么就报错。
方法解析 和字段解析类似
接口方法解析 注意接口继承自java.lang.Object吗？如果不，那么为什么接口能调用Object里面的方法呢？


初始化	初始化就是执行类构造器<clinit>()方法的过程
	* <clinit>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，
	定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
	* <clinit>方法与类的构造函数不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的此方法调用前，父类的<clinit>方法已经执行完毕。
	* <clinit>方法对于类或接口来说不是必须的，如果没有静态语句块，或者是对属性的赋值操作，那么编译器可以不为这个类生成<clinit>方法。
	* 接口中不能有静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>方法，但接口与类不一样，
		执行接口的<clinit>方法不需要先执行父接口的<clinit>方法，原因就是上面讲到的，在初始化一个接口时，不必初始化其父接口，这一点是与类初始化不同的。
	* 虚拟机必须保证一个类的<clinit>方法在多线程环境中被正确地加锁同步。



关于final关键字，请参考：https://www.cnblogs.com/wupeixuan/p/11750053.html



	
