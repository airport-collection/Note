# hashCode

```java
/**
* 
*/
@HotSpotIntrinsicCandidate    
public native int hashCode();
```

**hashCode**是**Object**类的一个本地方法，返回某个对象的哈希码，具体是怎么生成的，后面再说明，先看**hashCode**的一些规范

* 在Java应用程序的执行过程中，无论何时在同一个对象上多次调用它，**hashCode**方法都必须一致地返回相同的整数，前提是**equals**方法中比较的信息没有被修改。同一个应用程序多次执行**不要求**同一个对象的**hashCode**都相同。
* 如果**equals**判定两个对象相等（即返回值为true），那么这两个对象调用**hashCode**的返回值应该一样。
* 并不要求两个不相等（unequal）的对象的**hashCode**就一定不相等。但是程序员应该有意识做到不同的对象返回不同的**hashCode**，以此来提高哈希表的性能。

在相当大部分的情况下（注意不是绝对的），**Object**类中定义的**hashCode**方法会为不同对象返回不同的哈希码。**hashCode**可能会也可能不会实现为返回对象的内存地址。

# equals

```java
/**
* 
*/
public boolean equals(Object obj) {
    return (this == obj);
}
```

**equals**是**Object**中的方法之一，用于确定两个对象是否相等，注意这里的相等有两层含义：

1. 物理层面，即引用a, b指向内存中的同一个对象，这是物理层面相等，这也是运算符**"=="**所判断的内容。
2. 逻辑层面，可能引用a和b指向内存中不同位置的对象，但是指向的这两个位置的对象的某些属性是一致的，符合逻辑的，那么这也可以根据需求来判定是否相等。这也是常常重写**equals**方法的原因。

**equals**有以下几方面的性质：

* 反身性：对于任何非空引用**x**，**x.equals(x)**返回值应该为**true**。
* 对称性：对于任何非空引用**x**和**y**，**x.equals(y)**应该返回**true**, 当且仅当**y.equals(x)**返回值为**true**。
* 传递性：对于任何非空引用**x**、**y**和**z**，如果**x.equals(y)**和**y.equals(z)**都返回**true**，那么**x.equals(z)**返回值也应该为**true**。
* 一致性：对于任何非空引用**x**和**y**，假如判断逻辑所涉及的信息没有被改变，多次调用**x.equals(y)**都应该**一致地**返回**true**或者是**false**。
* 对空性：对于任何非空引用**x**，**x.equals(null)**都应该返回**false**。

<font color="red">默认情况下也就是从超类Object继承而来的equals方法与‘==’是完全等价的，比较的都是对象的内存地址，但我们可以重写equals方法，使其按照我们的需求的方式进行比较，如String类重写了equals方法，使其比较的是字符的序列，而不再是内存地址。</font>

# 重写equals

很多时候我们比较的不是**物理相等**而是**逻辑相等**，就需要重写，第二部分的论述中讨论了equals的一些性质，这是官方的定义，无论何时我们都应该遵守这几点要求。

<font color="red">为什么重写了equals方法就要重写hashCode方法？</font>

这个问题非常常见，所反映的实质也是很重要的，其危害性在一般场景可能不会出现，**但是当使用HashMap等依赖hashCode容器的时候，就会暴露问题，导致程序出错**。至于为什么会出错，<font color="green">后面补充！！！</font>









